library(purrr)
Sys.setenv(YELP_CLIENT_ID='**************')
Sys.setenv(YELP_SECRET='*****************************')
Sys.setenv(YELP_CLIENT_ID='OWaJGsdgrslg7QJcZAMCBA')
Sys.setenv(YELP_SECRET='MINTVTaxSJnSsf8X64JTycMHtpFdFVCVYN6OQNwP803UWXaCWSS7l0E3ydVWT33q')
Sys.getenv("YELP_CLIENT_ID")
Sys.getenv("YELP_SECRET")
library(yelpr) # devtools::install_github("jennybc/ryelp")
library(httr)
library(stringr)
library(purrr)
## https://www.yelp.com/developers/documentation/v3/authentication
yelp_endpoint <- oauth_endpoint(NULL,
authorize = "https://api.yelp.com/oauth2/token",
access = "https://api.yelp.com/oauth2/token")
token <- oauth2.0_token(yelp_endpoint, yelp_app,
user_params = list(grant_type = "client_credentials"),
use_oob = TRUE)
library(yelpr) # devtools::install_github("jennybc/ryelp")
library(httr)
library(stringr)
library(purrr)
yelp_app <- oauth_app("yelp", key = Sys.getenv("YELP_CLIENT_ID"),
secret = Sys.getenv("YELP_SECRET"))
# authenticate an endpoint
## https://www.yelp.com/developers/documentation/v3/authentication
yelp_endpoint <- oauth_endpoint(NULL,
authorize = "https://api.yelp.com/oauth2/token",
access = "https://api.yelp.com/oauth2/token")
token <- oauth2.0_token(yelp_endpoint, yelp_app,
user_params = list(grant_type = "client_credentials"),
use_oob = TRUE)
(url <-
modify_url("https://api.yelp.com", path = c("v3", "businesses", "search"),
query = list(term = "McDonalds",
location = "Boston, MA", limit = 10)))
res2 <- GET(url, config(token = token))
# was this api request successful?
http_status(res2)
# was this api request successful?
http_status(res2)$message
ct2 <- content(res2)
# create an object with resturant name and id for further calls
#sapply(ct2$businesses, function(x) x[c("name", "id")])
biz_info <- ct2$businesses %>%
map_df(`[`, c("name", "id", "phone", "review_count"))
biz_info
# was this api request successful?
http_status(res2)
res2$headers
# what type of format does the data come back with?
res2$headers$`content-type`
# was this api request successful?
http_status(res2)
# what type of format does the data come back with?
res2$headers$`content-type`
ct2 <- content(res2)
# create an object with resturant name and id for further calls
biz_info <- ct2$businesses %>%
map_df(`[`, c("name", "id", "phone", "review_count")) %>% knitr::kable()
biz_info
library(knitr)
(url_id <-
modify_url("https://api.yelp.com", path = c("v3", "businesses","mcdonalds-brighton-2", "reviews"),
query = list( locale = "en_US")))
url_id_f <- function(id) {
modify_url("https://api.yelp.com", path = c("v3", "businesses", id, "reviews"),
query = list( locale = "en_US"))
}
biz_reviews <- data.frame()
biz_reviews <-  map_chr(biz_info$id, url_id_f) %>%
data.frame(url = .)
ct2 <- content(res2)
# create an object with resturant name and id for further calls
biz_info <- ct2$businesses %>%
map_df(`[`, c("name", "id", "phone", "review_count")) %>% knitr::kable()
biz_info
ct2 <- content(res2)
# create an object with resturant name and id for further calls
biz_info <- ct2$businesses %>%
map_df(`[`, c("name", "id", "phone", "review_count"))
biz_info %>% knitr::kable()
(url_id <-
modify_url("https://api.yelp.com", path = c("v3", "businesses","mcdonalds-brighton-2", "reviews"),
query = list( locale = "en_US")))
url_id_f <- function(id) {
modify_url("https://api.yelp.com", path = c("v3", "businesses", id, "reviews"),
query = list( locale = "en_US"))
}
biz_reviews <- data.frame()
biz_reviews <-  map_chr(biz_info$id, url_id_f) %>%
data.frame(url = .)
biz_reviews
View(biz_reviews)
# retrieve info from the server
res3 <- GET(url_id, config(token = token))
# was this api request successful?
http_status(res3)
# return some geolocation data, business info & categories
ct3 <- content(res3)
# retrieve info from the server
res3 <- GET(url_id, config(token = token))
# was this api request successful?
http_status(res3)
# return some geolocation data, business info & categories
ct3 <- content(res3)
# Detect for string of 'mustard'
#str_detect(ct3[["reviews"]][[3]][["text"]], "mustard")
ct3$reviews %>%
map_df(`[`, c("text")) %>%
str_detect("mustard")
# Detect for string of 'mustard'
#str_detect(ct3[["reviews"]][[3]][["text"]], "mustard")
ct3$reviews %>%
map_df(`[`, c("text")) %>%
str_detect("mustard")
shiny::runApp('_drafts/not_mustard_files')
install.packages("shinydashboard")
runApp('_drafts/not_mustard_files')
get.wd()
getwd()
shiny::runApp('_drafts/not_mustard_files')
shiny::runApp('_drafts/not_mustard_files')
runApp('_drafts/not_mustard_files')
shiny::runApp('_drafts/not_mustard_files')
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE
)
library(emo)
library(knitr)
Sys.getenv()
Sys.setenv(YELP_SECRET='MINTVTaxSJnSsf8X64JTycMHtpFdFVCVYN6OQNwP803UWXaCWSS7l0E3ydVWT33q')
Sys.setenv(YELP_CLIENT_ID='OWaJGsdgrslg7QJcZAMCBA')
library(yelpr) # devtools::install_github("jennybc/ryelp")
library(httr)
library(stringr)
library(purrr)
yelp_app <- oauth_app("yelp", key = Sys.getenv("YELP_CLIENT_ID"),
secret = Sys.getenv("YELP_SECRET"))
# authenticate an endpoint
## https://www.yelp.com/developers/documentation/v3/authentication
yelp_endpoint <- oauth_endpoint(NULL,
authorize = "https://api.yelp.com/oauth2/token",
access = "https://api.yelp.com/oauth2/token")
token <- oauth2.0_token(yelp_endpoint, yelp_app,
user_params = list(grant_type = "client_credentials"),
use_oob = F, cache = T) # make this arg TRUE when interactive
(url <-
modify_url("https://api.yelp.com", path = c("v3", "businesses", "search"),
query = list(term = "McDonalds",
location = "Boston, MA", limit = 10)))
res2 <- GET(url, config(token = token))
# was this api request successful?
http_status(res2)
# what type of format does the data come back with?
res2$headers$`content-type`
ct2 <- content(res2)
# create an object with resturant name and id for further calls
biz_info <- ct2$businesses %>%
map_df(`[`, c("name", "id", "phone", "review_count"))
biz_info %>% knitr::kable()
(url_id <-
modify_url("https://api.yelp.com", path = c("v3", "businesses","mcdonalds-brighton-2", "reviews"),
query = list( locale = "en_US")))
# purrr version
url_id_f <- function(id) {
modify_url("https://api.yelp.com", path = c("v3", "businesses", id, "reviews"),
query = list( locale = "en_US"))
}
biz_reviews <- data.frame()
biz_reviews <-  map_chr(biz_info$id, url_id_f) %>%
data.frame(url = .)
biz_reviews %>% knitr::kable() # nicely print
# retrieve info from the server
res3 <- GET(url_id, config(token = token))
# was this api request successful?
http_status(res3)
# return some geolocation data, business info & categories
ct3 <- content(res3)
# Detect for string of 'mustard'
ct3$reviews %>%
map_df(`[`, c("text")) %>%
str_detect("mustard")
library(yelpr) # devtools::install_github("jennybc/ryelp")
library(httr)
library(stringr)
library(purrr)
yelp_app <- oauth_app("yelp", key = Sys.getenv("YELP_CLIENT_ID"),
secret = Sys.getenv("YELP_SECRET"))
yelp_endpoint <- oauth_endpoint(NULL,
authorize = "https://api.yelp.com/oauth2/token",
access = "https://api.yelp.com/oauth2/token")
token <- oauth2.0_token(yelp_endpoint, yelp_app,
user_params = list(grant_type = "client_credentials"),
use_oob = T) # make this arg TRUE when interactive
(url <-
modify_url("https://api.yelp.com", path = c("v3", "businesses", "search"),
query = list(term = "McDonalds",
location = "Hartford, CT", limit = 10)))
# 5. Retrieve info from the server with the `GET` verb: HTTP response verbs enable the client to send us back data on: status, headers, and body/content. Available verbs include **`GET`ting** data from the server, **`POST`ing** new data to the server, **`PUT`** new data to update a partial record and **`DELETE`ing** data.
## - HTTP status codes consist of 3 digit numeric codes for status (1xx is information, 2xx is success, 3xx is redirection, 4xx is client error, 5xx server error).
res2 <- GET(url, config(token = token))
# 5. Retrieve info from the server with the `GET` verb: HTTP response verbs enable the client to send us back data on: status, headers, and body/content. Available verbs include **`GET`ting** data from the server, **`POST`ing** new data to the server, **`PUT`** new data to update a partial record and **`DELETE`ing** data.
## - HTTP status codes consist of 3 digit numeric codes for status (1xx is information, 2xx is success, 3xx is redirection, 4xx is client error, 5xx server error).
res2 <- GET(url, config(token = token))
# was this api request successful?
http_status(res2)
# what type of format does the data come back with?
res2$headers$`content-type`
# 6. Return some geolocation data, business info & categories
ct2 <- content(res2)
biz_info <- ct2$businesses %>%
map_df(`[`, c("name", "id", "phone", "review_count"))
biz_info %>% knitr::kable()
url_id <- modify_url("https://api.yelp.com",
path = c("v3", "businesses","mcdonalds-glastonbury", "reviews"),
query = list( locale = "en_US"))
biz_reviews <- data.frame()
biz_reviews <-  map_chr(biz_info$id, url_id_f) %>%
data.frame(url = .)
biz_reviews %>% knitr::kable() # nicely print
class(res3)
View(res2)
?map
map_if
?map_if
?possibly
map(biz_reviews$url, GET, config(token = token))
map(as.character(biz_reviews$url), GET, config(token = token))
# 8. Retrieve response data on up to 3 reviews for the specific McDonald's
#res3 <- GET(url_id, config(token = token))
res3 <- map(as.character(biz_reviews$url), GET, config(token = token))
# was this api request successful?
http_status(res3)
View(res3)
res3 %>% map_df(`[`, "status_code") %>% http_status()
res3 %>% map_df(`[`, "status_code")
res3 %>% map_df(`[`, "status_code") == 200
res3[[1]]$content
# 8. Retrieve response data on up to 3 reviews for the specific McDonald's
res3 <- GET(url_id, config(token = token))
View(res3)
url_id <- modify_url("https://api.yelp.com",
path = c("v3", "businesses","mcdonalds-glastonbury", "reviews"),
query = list( locale = "en_US"))
url_id
# 8. Retrieve response data on up to 3 reviews for the specific McDonald's
res3 <- GET(url_id, config(token = token))
# was this api request successful?
res3 %>% map_df(`[`, "status_code") == 200
http_status(res3)
res3$content
View(res3$content)
?content
content(res3$content)
content(res3)
# return some geolocation data, business info & categories
ct3 <- content(res3)
View(ct3)
biz_reviews <- data.frame()
biz_reviews <-  map_chr(biz_info$id, url_id_f) %>%
data.frame(url = .) %>% as.character()
biz_reviews <- data.frame()
biz_reviews <-  map_chr(biz_info$id, url_id_f) %>%
data.frame(url = .) %>% as.character("url")
biz_reviews <- data.frame()
biz_reviews <-  map_chr(biz_info$id, url_id_f) %>%
data.frame(url = .)
biz_reviews <- data.frame()
biz_reviews <-  map_chr(biz_info$id, url_id_f) %>%
data.frame(url = as.chracter(.) )
biz_reviews <- data.frame()
biz_reviews <-  map_chr(biz_info$id, url_id_f) %>%
data.frame(url = as.character(.) )
biz_reviews <- data.frame()
biz_reviews <-  map_chr(biz_info$id, url_id_f) %>%
data.frame(url = .)
biz_reviews <- data.frame()
biz_reviews <-  map_chr(biz_info$id, url_id_f) %>%
data.frame(url = .)
biz_reviews$url <- as.character(biz_reviews$url)
# 8. Retrieve response data on up to 3 reviews for the specific McDonald's
#res3 <- GET(url_id, config(token = token))
res3 <- map(biz_reviews$url, GET, config(token = token))
rm("enter")
rm("exit")
rm("date")
rm("work_hrs")
View(merge_time_sheet)
rm("merge_time_sheet")
View(res3)
View(res2)
View(res3)
View(ct2)
View(ct2)
res3 %>% map_df(`[`, c("url", "status_code"))
names(res3)
names(res3[[1]])
dput(names(res3[[1]]))
res3 %>% map_df(`[`, c("url", "status_code", "headers", "all_headers", "cookies",
"content", "date", "times", "request", "handle"))
res3 %>% map(`[`, c("url", "status_code", "headers", "all_headers", "cookies",
"content", "date", "times", "request", "handle"))
res3 %>% map(`[`, content, c("url", "status_code", "headers", "all_headers", "cookies",
"content", "date", "times", "request", "handle"))
?map2
res3[[1]] %>% map(content)
res3[[1]]
str(res3)
first_mcd <- res3[[1]]
content(first_mcd)
ct3 <- map(res3[[1]], content)
ct3 <- map_df(res3[[1]], content)
length(res3)
content(first_mcd)
View(as.data.frame(content(first_mcd)))
ct3 <- map_df(res3[[1]][[1]], content)
ct3 <- map_df(res3[[1]][1], content)
ct3 <- map_df(res3[[1]], content)
# 5. Retrieve info from the server with the `GET` verb: HTTP response verbs enable the client to send us back data on: status, headers, and body/content. Available verbs include **`GET`ting** data from the server, **`POST`ing** new data to the server, **`PUT`** new data to update a partial record and **`DELETE`ing** data.
## - HTTP status codes consist of 3 digit numeric codes for status (1xx is information, 2xx is success, 3xx is redirection, 4xx is client error, 5xx server error).
response1 <- GET(url, config(token = token))
# was this api request successful?
http_status(response1)
# what type of format does the data come back with?
response1$headers$`content-type`
# 6. Return some content with geolocation data, business info & categories
ct2 <- content(response1)
biz_info <- ct2$businesses %>%
map_df(`[`, c("name", "id", "phone", "review_count"))
biz_info %>% knitr::kable()
url_id <- modify_url("https://api.yelp.com",
path = c("v3", "businesses","mcdonalds-glastonbury", "reviews"),
query = list( locale = "en_US"))
response2 <- GET(url_id, config(token = token))
content2 <- content(response2)
View(content2)
library(yelpr) # devtools::install_github("jennybc/ryelp")
library(httr)
library(stringr)
library(purrr)
# 1. Create an application on the [Yelp developers site](https://www.yelp.com/developers/v3/manage_app) and agree to the Terms and aggreements
## Set your credentials as environmental variables.
#Sys.setenv(YELP_CLIENT_ID='**************')
#Sys.setenv(YELP_SECRET='*****************************')
# 2. search for businesses by creating an app
yelp_app <- oauth_app("yelp", key = Sys.getenv("YELP_CLIENT_ID"),
secret = Sys.getenv("YELP_SECRET"))
# authenticate an endpoint
## https://www.yelp.com/developers/documentation/v3/authentication
yelp_endpoint <- oauth_endpoint(NULL,
authorize = "https://api.yelp.com/oauth2/token",
access = "https://api.yelp.com/oauth2/token")
# 3. Get an access token: Just enter anything for the authorization code when prompted in the Console of RStudio
token <- oauth2.0_token(yelp_endpoint, yelp_app,
user_params = list(grant_type = "client_credentials"),
use_oob = T) # make this arg TRUE when interactive
# 4. Create a url to make calls to the business search endpoint: The parts of the url include the endpoint and the query search parameters after the **?**
(url <-
modify_url("https://api.yelp.com", path = c("v3", "businesses", "search"),
query = list(term = "McDonalds",
location = "Hartford, CT", limit = 10)))
# 5. Retrieve info from the server with the `GET` verb: HTTP response verbs enable the client to send us back data on: status, headers, and body/content. Available verbs include **`GET`ting** data from the server, **`POST`ing** new data to the server, **`PUT`** new data to update a partial record and **`DELETE`ing** data.
## - HTTP status codes consist of 3 digit numeric codes for status (1xx is information, 2xx is success, 3xx is redirection, 4xx is client error, 5xx server error).
response1 <- GET(url, config(token = token))
# was this api request successful?
http_status(response1)
# what type of format does the data come back with?
response1$headers$`content-type`
# 6. Return some content with geolocation data, business info & categories
ct2 <- content(response1)
## create an object with resturant name and id for further calls
biz_info <- ct2$businesses %>%
map_df(`[`, c("name", "id", "phone", "review_count"))
biz_info %>% knitr::kable()
# 7. Get business reviews: After getting a specific McDonald's `id` restructure the url as an individual value and secondly creating a function to create a data.frame with urls for each business from the search endpoint.
url_id <- modify_url("https://api.yelp.com",
path = c("v3", "businesses","mcdonalds-glastonbury", "reviews"),
query = list( locale = "en_US"))
# 8. Retrieve response data on up to 3 reviews for the specific McDonald's
response2 <- GET(url_id, config(token = token))
content2 <- content(response2)
# Detect for string of 'mustard'
content2$reviews %>%
map_df(`[`, c("text")) %>%
str_detect("mustard")
content2$reviews %>%
map_df(`[`, c("text")) %>%
str_detect("mustard")
url_id_f <- function(id) {
modify_url("https://api.yelp.com", path = c("v3", "businesses", id, "reviews"),
query = list( locale = "en_US"))
}
biz_reviews <- data.frame()
biz_reviews <-  map_chr(biz_info$id, url_id_f) %>%
data.frame(url = .)
biz_reviews$url <- as.character(biz_reviews$url)
response3 <- map(biz_reviews$url, GET, config(token = token))
# was this api request successful?
response3 %>% map_df(`[`, "status_code") == 200
library(dplyr)
content_df <- data.frame()
for (idx in length(res3)) {
mcd <- res[[idx]]
ct <- content(mcd)
content_df <- bind_rows(content_df, ct)
}
for (idx in length(response3)) {
mcd <- response3[[idx]]
ct <- content(mcd)
content_df <- bind_rows(content_df, ct)
}
mcd <- response3[[1]]
mcd
ct <- content(mcd)
ct$reviews
content_df <- bind_rows(content_df, ct$reviews)
content_df <- data.frame()
for (idx in length(response3)) {
mcd <- response3[[idx]]
ct <- content(mcd)
#content_df <- bind_rows(content_df, ct$reviews)
ct$reviews %>%
map_df(`[`, c("text")) %>%
str_detect("mustard")
}
for (idx in length(response3)) {
mcd <- response3[[idx]]
ct <- content(mcd)
#content_df <- bind_rows(content_df, ct$reviews)
ct$reviews %>%
map_df(`[`, c("text")) %>%
str_detect("mustard")
}
for (idx in length(response3)) {
mcd <- response3[[idx]]
ct <- content(mcd)
#content_df <- bind_rows(content_df, ct$reviews)
ct$reviews %>%
map_df(`[`, c("text")) %>%
str_detect("mustard")
}
idx
for (idx in 1:length(response3)) {
mcd <- response3[[idx]]
ct <- content(mcd)
#content_df <- bind_rows(content_df, ct$reviews)
ct$reviews %>%
map_df(`[`, c("text")) %>%
str_detect("mustard")
}
for (idx in 1:length(response3)) {
mcd <- response3[[idx]]
ct <- content(mcd)
#content_df <- bind_rows(content_df, ct$reviews)
ct$reviews %>%
map_df(`[`, c("text")) %>%
str_detect("mustard")
}
for (idx in 1:length(response3)) {
mcd <- response3[[idx]]
ct <- content(mcd)
#content_df <- bind_rows(content_df, ct$reviews)
result <- ct$reviews %>%
map_df(`[`, c("text")) %>%
str_detect("mustard")
print(result)
}
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE
)
library(emo)
library(knitr)
for (idx in 1:length(response3)) {
mcd <- response3[[idx]]
ct <- content(mcd)
print(ct)
result <- ct$reviews %>%
map_df(`[`, c("text")) %>%
str_detect("mustard")
print(result)
}
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE
)
library(emo)
library(knitr)
library(yelpr) # devtools::install_github("jennybc/ryelp")
library(httr)
library(stringr)
library(purrr)
for (idx in 1:length(response3)) {
mcd <- response3[[idx]]
ct <- content(mcd)
print(ct)
result <- ct$reviews %>%
map_df(`[`, c("text")) %>%
str_detect("mustard")
print(result)
}
?GET
emo::ji("woman")
emo::ji("computers")
emo::ji("computer")
emo::ji("hamburger")
q()
